{
    "types": {
        "enum": {
            "name": "",
            "values": [
                "kTimeout"
            ]
        }
    },
    "methods": {
        "getKeywordId": {
            "brief": "Retrieve the keyword ID from its device and keyword friendly names",
            "params": {
                "deviceName": {
                    "direction": "in",
                    "brief": "Device name containing the keyword"
                },
                "keywordName": {
                    "direction": "in",
                    "brief": "Keyword name to search for ID"
                }
            },
            "return": "Found keyword ID",
            "throw": "Error if several (some have to be renamed) or none keyword ID found"
        },
        "getRecipientId": {
            "brief": "Retrieve the recipient ID from its first and last names",
            "params": {
                "firstName": {
                    "direction": "in",
                    "brief": "First name"
                },
                "lastName": {
                    "direction": "in",
                    "brief": "Last name"
                }
            },
            "return": "Found recipient ID",
            "throw": "Error if no recipient found"
        },
        "readKeyword": {
            "brief": "Read the last known state of the keyword",
            "params": {
                "keywordId": {
                    "direction": "in",
                    "brief": "The keyword ID we are interesting in"
                }
            },
            "return": "The last known keyword state (empty if no known state)",
            "throw": "Error if keyword not found"
        },
        "waitForAcquisition": {
            "brief": "Wait for a new acquisition on a keyword",
            "params": {
                "keywordId": {
                    "direction": "in",
                    "brief": "The keyword ID to watch"
                },
                "timeout": {
                    "direction": "in",
                    "brief": "Timeout to wait. Format is \"hh:mm:ss.xxx\". No timeout if empty (default)."
                }
            },
            "return": "The keyword new state (empty if timeout)",
            "throw": "Error if keyword not found"
        },
        "waitForAcquisitions": {
            "brief": "Wait for a new acquisition on a keyword list",
            "params": {
                "keywordIdList": {
                    "direction": "in",
                    "brief": "The keyword IDs list to watch"
                },
                "timeout": {
                    "direction": "in",
                    "brief": "Timeout to wait. Format is \"hh:mm:ss.xxx\". No timeout if empty (default)."
                }
            },
            "return": "Returned value is a pair of the keyword Id who changed, and its new value. The keyword Id is kTimeout if timeout.",
            "throw": "Error if at least one keyword was not found"
        },
        "writeKeyword": {
            "brief": "Change state of a keyword",
            "params": {
                "keywordId": {
                    "direction": "in",
                    "brief": "The keyword ID to change state"
                },
                "newState": {
                    "direction": "in",
                    "brief": "The keyword new state"
                }
            },
            "details": "Do nothing if keyword is not found or not writable",
            "throw": "Error if keyword not found"
        },
        "sendNotification": {
            "brief": "Send a notification",
            "params": {
                "keywordId": {
                    "direction": "in",
                    "brief": "The keyword ID to use to send notification"
                },
                "recipientId": {
                    "direction": "in",
                    "brief": "The recipient ID"
                },
                "message": {
                    "direction": "in",
                    "brief": "The message to send"
                }
            },
            "details": "Do nothing if keyword or recipient is not found or not writable",
            "throw": "Error if keyword or recipient not found"
        },
        "getInfo": {
            "brief": "Get general information",
            "params": {
                "key": {
                    "direction": "in",
                    "brief": "Information key"
                }
            },
            "return": "Information as string (empty string if not found)",,
            "throw": "Error if key doesn't exist",
            "details": [
                "Supported value (don't forget to prefix by 'yApi.') :",
                "- kSunrise : get current day sunrise time (format is "HH:MM")
                "- kSunset : get current day sunset time (format is "HH:MM")
                "- kLatitude : get latitude : returns latitude configured by user (or approximative latitude if not configured)",
                "- kLongitude : get longitude : returns latitude configured by user (or approximative longitude if not configured)",
                "- kAltitude : get altitude : returns latitude configured by user (or approximative altitude if not configured)",
                "- kYadomsServerOS : get yadoms server OS : returns a string containing the OS name where Yadoms is running",
                "- kYadomsServerVersion : get yadoms application version : returns a string containing the Yadoms application version"
            ]
        },
        "ruleEnable": {
            "brief": "Can be used to prevent a rule for auto-restart",
            "params": {
                "enable": {
                    "direction": "in",
                    "brief": "True to active auto-restart, False to disable the rule (after the current execution is complete)"
                }
            },
            "details": "By default, a rule auto-restart at its end"
        }
    }
}