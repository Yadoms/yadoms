#pragma once

#include "IExtendedEnum.h"
#include "shared/exception/Exception.hpp"
#include "shared/exception/OutOfRange.hpp"
/*

This class contains macros for defining extended macros which add the ability to use string and/or values for enum

//////////////////////////////////////////////
//MACRO usage
//////////////////////////////////////////////

   //////////////////////////////////////////
   //The header part
   //////////////////////////////////////////
   DECLARE_ENUM_HEADER(ECommand,
      ((Stop)(0))
      ((Open)(1))
      ((Close)(2))
   );

   or with SHARED
   
   DECLARE_ENUM_HEADER_SHARED(ECommand, YADOMS_SHARED_EXPORT,
   ((Stop)(0))
   ((Open)(1))
   ((Close)(2))
   );

   //////////////////////////////////////////
   //The implementation part 
   //////////////////////////////////////////

   //classic implementation, each string is generated by the name (Stop -> "stop")
   DECLARE_ENUM_IMPLEMENTATION(ECommand,
      (Stop)
      (Open)
      (Close)
   );   

   DECLARE_ENUM_IMPLEMENTATION_NESTED(CCurtain::ECommand, ECommand,
      (Stop)
      (Open)
      (Close)
   );

   //custom implementation, each string is defined by a custom name
   DECLARE_ENUM_IMPLEMENTATION_CUSTOM(ECommand,
      ((Stop)("customstop"))
      ((Open)("customopen"))
      ((Close)("customclose"))
   );

   DECLARE_ENUM_IMPLEMENTATION_CUSTOM_NESTED(CCurtain::ECommand, ECommand,
      ((Stop)("customstop"))
      ((Open)("customopen"))
      ((Close)("customclose"))
   );



//////////////////////////////////////////////
//MACRO expansion
//////////////////////////////////////////////

   //////////////////////////////////////////
   //The header part 
   //////////////////////////////////////////
   class ECommand: public shared::enumeration::IExtendedEnum 
   {
      public: enum domain 
      {
         kStop = 0 , 
         kOpen = 1 , 
         kClose = 2 ,
      };
      ECommand();
      ECommand(domain value);
      ECommand(const std::string & valueAsString);
      ECommand(const int valueAsInt);
      virtual ~ECommand();
      operator int() const;
      operator std::string() const;
      ECommand & operator=(int const& obj);
      ECommand & operator=(std::string const& obj);
      ECommand & operator=(const ECommand & obj);
      ECommand const operator() () const;
      const std::string & getAsString() const;
      void setFromString(const std::string & val);
      static ECommand parse(const std::string & val);
      static bool exists(const std::string & stringValue);                             
      static bool exists(const int intValue);                                          
   private: 
      domain m_value;
      static const std::string StopString;
      static const std::string OpenString;
      static const std::string CloseString;
   };

   //////////////////////////////////////////
   //The header part with SHARED
   //////////////////////////////////////////
   //same as above; with export
   class __declspec(dllexport) ECommand: public shared::enumeration::IExtendedEnum.....





   //////////////////////////////////////////
   //The implementation part
   //////////////////////////////////////////
   const std::string ECommand::StopString = boost::algorithm::to_lower_copy( std::string("Stop") );
   const std::string ECommand::OpenString = boost::algorithm::to_lower_copy( std::string("Open") );
   const std::string ECommand::CloseString = boost::algorithm::to_lower_copy( std::string("Close") );

   ECommand::ECommand() 
      : m_value( kStop ) 
   {
   }
   
   ECommand::ECommand(domain value) 
      : m_value(value) 
   {
   }
   
   ECommand::ECommand(const std::string & valueAsString) 
   {
      setFromString(valueAsString);
   }
   ECommand::ECommand(const int valueAsInt) 
      : m_value((domain)valueAsInt) 
   {
   }
   
   ECommand::~ECommand() 
   {
   }
   
   ECommand::operator int() const 
   {
      return m_value;
   }
   ECommand::operator std::string() const 
   {
      return getAsString();
   }
   ECommand const ECommand::operator() () const 
   {
      return m_value;
   }
   ECommand & ECommand::operator=(int const& obj) 
   {
      m_value = (domain)obj;
      return *this;
   }
   ECommand & ECommand::operator=(const ECommand & obj) 
   {
      m_value = obj.m_value;
      return *this;
   }
   ECommand & ECommand::operator=(std::string const& obj) 
   {
      setFromString(obj);
      return *this;
   }
   const std::string & ECommand::getAsString() const 
   {
      switch (m_value) 
      {
      case kStop: 
         return StopString;
      case kOpen: 
         return OpenString;
      case kClose: 
         return CloseString;
      default: 
         throw shared::exception::COutOfRange("Invalid enum value");
      }
   }

   void ECommand::setFromString(const std::string & val)
   {
      if (boost::iequals(val, StopString)) 
         m_value = kStop; 
      else if (boost::iequals(val, OpenString)) 
         m_value = kOpen; 
      else if (boost::iequals(val, CloseString)) 
         m_value = kClose; 
      else   
         throw shared::exception::COutOfRange(val);
   }
  
   ECommand parse(const std::string & val)
   {
      ECommand local;                                                                                                       \
      local.setFromString(val);                                                                                                              \
      return local;   
   }

   bool exists(const std::string & val)
   {
      bool exist = false;
      
      if (boost::iequals(val, StopString)) 
         exist = true;
      else if (boost::iequals(val, OpenString)) 
         exist = true;
      else if (boost::iequals(val, CloseString)) 
         exist = true;
      else   
         exist = false;
   }
   
   bool exists(const int val)
   {
      switch (val) 
      {
      case kStop: 
      case kOpen: 
      case kClose: 
         return true;
      default: 
         return false;
      }
   }

  //////////////////////////////////////////
  //The implementation part for nested
  //////////////////////////////////////////
  //same as above, with container class specifier

  const std::string CCurtain::ECommand::StopString = boost::algorithm::to_lower_copy( std::string("Stop") );
  
  CCurtain::ECommand::ECommand()
  : m_value( kStop )
  {
  }

  //////////////////////////////////////////
  //The implementation part for custom
  //////////////////////////////////////////
  //same as above, with container class specifier

  const std::string CCurtain::ECommand::StopString = std::string("customstop");


*/




//
/// \brief In the sequence of enum values, the first column is the name
//
#define ENUM_COLUMN_NAME   0

//
/// \brief In the sequence of enum values, the second column is the value
//
#define ENUM_COLUMN_VALUE  1

//
/// \brief In the sequence of enum values, the second column is the value
//
#define ENUM_COLUMN_STRING  1

//
/// \brief Give the real enum name (appending a E before the enumName)
//
#define ENUM_CLASSNAME(_enumName) _enumName

//
/// \brief Give the name of a value (in implementation) : (Off) -> kOff
//
#define ENUM_EXTRACT_NAME_IMPL(_seq) BOOST_PP_CAT(k, _seq)
//
/// \brief Give the variable name of an enum value string  (in implementation): (Off) -> OffString
//
#define ENUM_EXTRACT_CONST_NAME_IMPL(_seq) BOOST_PP_CAT(_seq, String)

//
/// \brief Give the name of a value (in header) : ((Off)(0)) -> kOff
//
#define ENUM_EXTRACT_NAME(_elem) BOOST_PP_CAT(k, BOOST_PP_SEQ_ELEM(ENUM_COLUMN_NAME, _elem))


//
/// \brief Give the domain name of a value (in header) : ((Off)(0)) -> kOffValue
//
#define ENUM_EXTRACT_DOMAINNAME(_elem) BOOST_PP_CAT(ENUM_EXTRACT_NAME(_elem), Value)


//
/// \brief Give the name of a value (in header) : ((Off)(0)) -> Off
//
#define ENUM_EXTRACT_NAME_RAW(_seq) BOOST_PP_SEQ_ELEM(ENUM_COLUMN_NAME, _seq)

//
/// \brief Give the value (in header) : ((Off)(0)) -> 0
//
#define ENUM_EXTRACT_VALUE(_seq) BOOST_PP_SEQ_ELEM(ENUM_COLUMN_VALUE, _seq)


//
/// \brief Give the variable name of an enum value string (in header) : ((Off)(0)) -> OffString
//
#define ENUM_EXTRACT_CONST_STRINGNAME(_seq) ENUM_EXTRACT_CONST_NAME_IMPL(BOOST_PP_SEQ_ELEM(ENUM_COLUMN_NAME, _seq))

//
/// \brief Give the variable name of an enum value string (in header) : ((Off)(0)) -> kOff
//
#define ENUM_EXTRACT_CONST_NAME(_seq) ENUM_EXTRACT_NAME_IMPL(BOOST_PP_SEQ_ELEM(ENUM_COLUMN_NAME, _seq))


#define DECLARE_VALUE_OR_AUTOINC(_seq, _r) \
   BOOST_PP_IF(BOOST_PP_EQUAL(BOOST_PP_SEQ_SIZE(_seq), 2 ), ENUM_EXTRACT_VALUE(_seq), _r)

#define DECLARE_NAME_OR_STRINGIZE(_seq) \
   BOOST_PP_IF(BOOST_PP_EQUAL(BOOST_PP_SEQ_SIZE(_seq), 2 ), std::string( ENUM_EXTRACT_VALUE(_seq) ), boost::algorithm::to_lower_copy( std::string(BOOST_PP_STRINGIZE( ENUM_EXTRACT_NAME_RAW(_seq))) ))


//
/// \brief Macro used to declare one enum value
//
#define DECLARE_ENUM_STATIC_VALUE(r, _enumName, elem)   static const ENUM_CLASSNAME(_enumName) ENUM_EXTRACT_NAME(elem);								

//
/// \brief Macro used to declare all the enum values
//
#define DECLARE_ENUM_STATIC_VALUES(_enumName, _seq)	BOOST_PP_SEQ_FOR_EACH(DECLARE_ENUM_STATIC_VALUE, _enumName, _seq)     


//
/// \brief Macro used to declare one enum value (constant value, usable in switch/case statements)
//
#define DECLARE_DOMAIN_VALUE(r, _notused, i, elem)   ENUM_EXTRACT_DOMAINNAME(elem)  = DECLARE_VALUE_OR_AUTOINC(elem, i),								

//
/// \brief Macro used to declare all the enum values (constant value, usable in switch/case statements)
//
#define DECLARE_DOMAIN_VALUES(_seq)	                              \
      enum domain   {                                             \
         BOOST_PP_SEQ_FOR_EACH_I(DECLARE_DOMAIN_VALUE, _, _seq)   \
      };



//
/// \brief Macro used to declare in header the string of one value
//
#define ENUM_DECLARE_STATIC_CONST_NAME(r, _enumName, elem)	static const std::string ENUM_EXTRACT_CONST_STRINGNAME(elem);

//
/// \brief Macro used to declare in header the string of each value
//
#define ENUM_DECLARE_STATIC_CONST_NAMES(_seq)   BOOST_PP_SEQ_FOR_EACH(ENUM_DECLARE_STATIC_CONST_NAME, _, _seq)     



//
/// \brief Macro used to declare the Enum class header with possibility of export/import from/to a shared library
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _export       The export class specifier (can be __declspec(dllexport/dllimport) for MSVC, or extern "C" for unix systems
/// \param [in] _seq          The enumeration sequence
//
#define DECLARE_ENUM_HEADER_SHARED_TYPE(_enumName, _export, _type, _seq) 					                                 \
   class _export ENUM_CLASSNAME(_enumName): public shared::enumeration::IExtendedEnum                                   \
	{                                                                                                                    \
	public:                                                                                                              \
		DECLARE_DOMAIN_VALUES(_seq)						    						                                                \
		DECLARE_ENUM_STATIC_VALUES(_enumName, _seq)						    						                                 \
		ENUM_CLASSNAME(_enumName)();																	                                    \
		ENUM_CLASSNAME(_enumName)(const ENUM_CLASSNAME(_enumName) & valueTocopy);                                         \
		ENUM_CLASSNAME(_enumName)(const std::string & valueAsString);	    				                                    \
		ENUM_CLASSNAME(_enumName)(const char * valueAsString);	    				                                          \
		ENUM_CLASSNAME(_enumName)(const _type valueAsInt);	    				                                                \
		virtual ~ENUM_CLASSNAME(_enumName)();														                                    \
		operator _type() const;																			                                    \
		operator std::string() const;																	                                    \
		ENUM_CLASSNAME(_enumName) & operator=(_type const& obj);								                                    \
		ENUM_CLASSNAME(_enumName) & operator=(std::string const& obj);						                                    \
		ENUM_CLASSNAME(_enumName) & operator=(const char * obj);						                                          \
		ENUM_CLASSNAME(_enumName) & operator=(const ENUM_CLASSNAME(_enumName) & obj);	                                    \
		ENUM_CLASSNAME(_enumName) const operator() () const;						                                             \
		const std::string & toString() const;													                                       \
      const int toInteger() const;                                                                                      \
		virtual void fromString(const std::string & val);													                           \
      static ENUM_CLASSNAME(_enumName) parse(const std::string & val);                                                  \
      static bool isDefined(const std::string & stringValue);                                                           \
      static bool isDefined(const int intValue);                                                                        \
	private:																									                                    \
		_type   m_value;																					                                    \
      ENUM_DECLARE_STATIC_CONST_NAMES(_seq);														                                    \
	};																											

//
/// \brief Macro used to declare the Enum class header 
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _seq          The enumeration sequence ((On)(0)) ((Off)(1)) ((Dim)(2))
//
#define DECLARE_ENUM_HEADER(_enumName, _seq)	DECLARE_ENUM_HEADER_SHARED_TYPE(_enumName, , int, _seq)			

//
/// \brief Macro used to declare the Enum class header with an underlying type
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _seq          The enumeration sequence ((On)(0)) ((Off)(1)) ((Dim)(2))
/// \param [in] _type         The enumeration type (int, unsigned int, short,....)
//
#define DECLARE_ENUM_HEADER_TYPE(_enumName, _seq, _type)	DECLARE_ENUM_HEADER_SHARED_TYPE(_enumName, , _type, _seq)			

//
/// \brief Macro used to declare the Enum class header with possibility of export/import from/to a shared library
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _export       The export class specifier (can be __declspec(dllexport/dllimport) for MSVC, or extern "C" for unix systems
/// \param [in] _seq          The enumeration sequence
//
#define DECLARE_ENUM_HEADER_SHARED(_enumName, _export, _seq)   DECLARE_ENUM_HEADER_SHARED_TYPE(_enumName, _export, int, _seq)			


 

//
/// \brief Macro used to declare the implementation of GetAsString method for one case
//
#define ENUM_DECLARE_GETASSTRING(r, _enumName, elem) case ENUM_EXTRACT_DOMAINNAME(elem): return ENUM_EXTRACT_CONST_STRINGNAME(elem);


//
/// \brief Macro used to declare the implementation of GetAsString method
//
#define ENUM_DECLARE_GETASSTRING_IMPL(_seq) BOOST_PP_SEQ_FOR_EACH(ENUM_DECLARE_GETASSTRING, _, _seq)     


   
//
/// \brief Macro used to declare the implementation of SetFromString method for one case
//
#define ENUM_DECLARE_SETFROMSTRING(r, _enumName, elem)									                        \
   if (boost::iequals(val, ENUM_EXTRACT_NAME_IMPL( ENUM_EXTRACT_NAME_RAW(elem) ).toString()))            \
      m_value = ENUM_EXTRACT_DOMAINNAME(elem);                             \
   else                                                                                

   
//
/// \brief Macro used to declare the implementation of SetFromString method
//
#define ENUM_DECLARE_SETFROMSTRING_IMPL(_seq) BOOST_PP_SEQ_FOR_EACH(ENUM_DECLARE_SETFROMSTRING, _, _seq)     






//
/// \brief Macro used to declare the implementation of exists(int) method for one case
//
#define ENUM_DECLARE_ISDEFINED_INT(r, _enumName, elem)  case ENUM_EXTRACT_DOMAINNAME(elem):

 

//
/// \brief Macro used to declare the implementation of exists(int) method
//
#define ENUM_DECLARE_ISDEFINED_INT_IMPL(_seq) BOOST_PP_SEQ_FOR_EACH(ENUM_DECLARE_ISDEFINED_INT, _, _seq)     





//
/// \brief Macro used to declare the implementation of exists(string) method for one case
//
#define ENUM_DECLARE_ISDEFINED_STRING(r, _enumName, elem)	                                             \
   if (boost::iequals(val, ENUM_EXTRACT_NAME_IMPL(ENUM_EXTRACT_NAME_RAW(elem)).toString()))              \
      return true;                                                                                       \
   else                                                                                


//
/// \brief Macro used to declare the implementation of exists(string) method
//
#define ENUM_DECLARE_ISDEFINED_STRING_IMPL(_seq) BOOST_PP_SEQ_FOR_EACH(ENUM_DECLARE_ISDEFINED_STRING, _, _seq)     


//
/// \brief Macro used to declare the definition of one static enum name string with custom definition
//   
//#define ENUM_DECLARE_STATIC_CONST_ENUM_IMPL(r, _fullEnumNameAndEnumName, elem) const BOOST_PP_SEQ_ELEM(1, _fullEnumNameAndEnumName) BOOST_PP_SEQ_ELEM(0, _fullEnumNameAndEnumName)::ENUM_EXTRACT_CONST_NAME( elem )( ENUM_EXTRACT_VALUE(elem) );
#define ENUM_DECLARE_STATIC_CONST_ENUM_IMPL(r, _fullEnumNameAndEnumName, i, elem) \
   const BOOST_PP_SEQ_ELEM(0, _fullEnumNameAndEnumName) BOOST_PP_SEQ_ELEM(0, _fullEnumNameAndEnumName)::ENUM_EXTRACT_CONST_NAME( elem )( BOOST_PP_SEQ_ELEM(0, _fullEnumNameAndEnumName)::ENUM_EXTRACT_DOMAINNAME(elem) ); 

//
/// \brief Macro used to declare the definition of static enum name strings with custom definition
//   
#define ENUM_DECLARE_STATIC_CONST_ENUMS_IMPL(_fullEnumNameAndEnumName, _seq) BOOST_PP_SEQ_FOR_EACH_I(ENUM_DECLARE_STATIC_CONST_ENUM_IMPL, _fullEnumNameAndEnumName, _seq)     


//
/// \brief Macro used to declare the definition of one static enum name string
//   
#define ENUM_DECLARE_STATIC_CONST_NAME_IMPL(r, _fullEnumName, elem) const std::string _fullEnumName::ENUM_EXTRACT_CONST_STRINGNAME(elem) = DECLARE_NAME_OR_STRINGIZE(elem);

//
/// \brief Macro used to declare the definition of static enum name strings
//   
#define ENUM_DECLARE_STATIC_CONST_NAMES_IMPL(_fullClassifiedEnumName, _seq) BOOST_PP_SEQ_FOR_EACH(ENUM_DECLARE_STATIC_CONST_NAME_IMPL, _fullClassifiedEnumName, _seq)     


#define CHECK_VALUE(val)      if(!isDefined(val)) throw shared::exception::COutOfRange("Invalid enum value"); 

//
/// \brief Macro used to declare the Enum class implementation with possibility of defining it as a nested class
/// \param [in] _fullClassifiedEnumName The enumeration name if nested : ex : CMyClass::EMyEnum
/// \param [in] __enumName       	The namespace to use without full qualified name : EMyEnum
/// \param [in] _type          The enumeration inner type (can be int, short,...)
/// \param [in] _seq          The enumeration sequence ((Off)("off")) or ((Off)) . The second parameter is optional. By default this is the first parameter stringized as lower
//
#define DECLARE_ENUM_IMPLEMENTATION_NESTED_TYPE(_fullClassifiedEnumName, _enumName, _type, _seq)                                                \
   ENUM_DECLARE_STATIC_CONST_ENUMS_IMPL((_fullClassifiedEnumName)(_enumName), _seq)                                                             \
   ENUM_DECLARE_STATIC_CONST_NAMES_IMPL(_fullClassifiedEnumName, _seq)                                                                          \
   _fullClassifiedEnumName::ENUM_CLASSNAME(_enumName)() : m_value( ENUM_EXTRACT_NAME(BOOST_PP_SEQ_HEAD(_seq)) ) {CHECK_VALUE(m_value); }        \
   _fullClassifiedEnumName::ENUM_CLASSNAME(_enumName)(const _type value) : m_value(value) {CHECK_VALUE(m_value);}                               \
   _fullClassifiedEnumName::ENUM_CLASSNAME(_enumName)(const std::string & val): m_value(parse(val).m_value) {}                                  \
   _fullClassifiedEnumName::ENUM_CLASSNAME(_enumName)(const char * val): m_value(parse(std::string(val)).m_value) {}                            \
   _fullClassifiedEnumName::ENUM_CLASSNAME(_enumName)(const ENUM_CLASSNAME(_enumName) & val): m_value(val.m_value) {CHECK_VALUE(m_value);}      \
   _fullClassifiedEnumName::~ENUM_CLASSNAME(_enumName)() {}                                                                                     \
   _fullClassifiedEnumName::operator _type() const { return m_value; }                                                                          \
   const int _fullClassifiedEnumName::toInteger() const { return m_value; }                                                                     \
   _fullClassifiedEnumName::operator std::string() const { return toString(); }                                                                 \
   _fullClassifiedEnumName const _fullClassifiedEnumName::operator() () const { return m_value; }						                              \
   _fullClassifiedEnumName & _fullClassifiedEnumName::operator=(_type const& obj)                                                               \
   {                                                                                                                                            \
      m_value = obj;                                                                                                                            \
      CHECK_VALUE(m_value);                                                                                                                     \
      return *this;                                                                                                                             \
   }                                                                                                                                            \
   _fullClassifiedEnumName & _fullClassifiedEnumName::operator=(const ENUM_CLASSNAME(_enumName) & obj)                                          \
   {                                                                                                                                            \
      m_value = obj.m_value;                                                                                                                    \
      CHECK_VALUE(m_value);                                                                                                                     \
      return *this;                                                                                                                             \
   }                                                                                                                                            \
   _fullClassifiedEnumName & _fullClassifiedEnumName::operator=(std::string const& obj)                                                         \
   {                                                                                                                                            \
      m_value = parse(obj).m_value;                                                                                                             \
      return *this;                                                                                                                             \
   }                                                                                                                                            \
   _fullClassifiedEnumName & _fullClassifiedEnumName::operator=(const char * obj)                                                               \
   {                                                                                                                                            \
      m_value = parse(std::string(obj)).m_value;                                                                                                \
      return *this;                                                                                                                             \
   }                                                                                                                                            \
   const std::string & _fullClassifiedEnumName::toString() const                                                                                \
	{                                                                                                                                            \
      switch(m_value)                                                                                                                           \
      {                                                                                                                                         \
		   ENUM_DECLARE_GETASSTRING_IMPL(_seq)                                                                                                    \
		   default : throw shared::exception::COutOfRange("Invalid enum value");                                                                  \
      }                                                                                                                                         \
   }                                                                                                                                            \
	void _fullClassifiedEnumName::fromString(const std::string & val)                                                                            \
	{                                                                                                                                            \
		ENUM_DECLARE_SETFROMSTRING_IMPL(_seq)                                                                                                     \
      throw shared::exception::COutOfRange(val);                                                                                                \
	}                                                                                                                                            \
   _fullClassifiedEnumName _fullClassifiedEnumName::parse(const std::string & val)                                                              \
   {                                                                                                                                            \
      ENUM_CLASSNAME(_enumName) local;                                                                                                          \
      local.fromString(val);                                                                                                                    \
      return local;                                                                                                                             \
   }                                                                                                                                            \
   bool _fullClassifiedEnumName::isDefined(const std::string & val)                                                                             \
   {                                                                                                                                            \
      ENUM_DECLARE_ISDEFINED_STRING_IMPL(_seq)                                                                                                  \
      return false;                                                                                                                             \
   }                                                                                                                                            \
   bool _fullClassifiedEnumName::isDefined(const _type val)                                                                                     \
   {                                                                                                                                            \
      switch(val)                                                                                                                               \
      {                                                                                                                                         \
         ENUM_DECLARE_ISDEFINED_INT_IMPL(_seq)                                                                                                  \
            return true;                                                                                                                        \
         default :                                                                                                                              \
            return false;                                                                                                                       \
      }                                                                                                                                         \
   }      

//
/// \brief Macro used to declare the Enum class implementation
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _seq          The enuemration sequence (Off)(On)(Dim)
//   
#define DECLARE_ENUM_IMPLEMENTATION(_enumName, _seq)  DECLARE_ENUM_IMPLEMENTATION_NESTED_TYPE(_enumName, _enumName, int, _seq)

//
/// \brief Macro used to declare a NESTED Enum class implementation
/// \param [in] _fullClassifiedEnumName     The full qualified name: CMyClass::ETest
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _seq          The enuemration sequence (Off)(On)(Dim)
//  
#define DECLARE_ENUM_IMPLEMENTATION_NESTED(_fullClassifiedEnumName, _enumName, _seq) DECLARE_ENUM_IMPLEMENTATION_NESTED_TYPE(_fullClassifiedEnumName, _enumName, int, _seq)

//
/// \brief Macro used to declare the Enum class implementation
/// \param [in] _enumName     The enumeration name : Test : will give "enum ETest {..."
/// \param [in] _type         The real type of enumeration values (int, short,...)
/// \param [in] _seq          The enuemration sequence (Off)(On)(Dim)
//   
#define DECLARE_ENUM_IMPLEMENTATION_TYPE(_enumName, _type, _seq)  DECLARE_ENUM_IMPLEMENTATION_NESTED_TYPE(_enumName, _enumName, _type, _seq)

